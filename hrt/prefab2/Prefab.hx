package hrt.prefab2;


typedef PrefabField = {
    var name : String;
    var hasSetter : Bool;
    var meta : PrefabMeta;
}

typedef PrefabMeta = {
    var ?doc : String;
    var ?range_min : Float;
    var ?range_max : Float;
    var ?range_step : Float;
}

typedef PrefabInfo = {prefabClass : Class<Prefab> #if editor, inf : hide.prefab2.HideProps #end};

@:keepSub
@:autoBuild(hrt.prefab2.Macros.buildPrefab())
@:build(hrt.prefab2.Macros.buildPrefab())
class Prefab {
    @:s public var name : String = "";
    @:s public var props : Any = null;
    @:s public var enabled : Bool = true;
    @:s public var editorOnly : Bool = true;
    @:s public var inGameOnly : Bool = true;
	@:s public var locked : Bool = false;
    

    // Todo : generate through macros
    public var type(get, never) : String;

    function get_type() {
        var thisClass = Type.getClass(this);
        return getClassTypeName(thisClass);
    }

    public var children : Array<Prefab> = [];

    public var parent : Prefab = null;

    /**The original prefab that this prefab is derived from.**/
    public var proto : ProtoPrefab = null;

    public function getLocal2d() : h2d.Object {
        return null;
    }

    public function getFirstLocal2d() : h2d.Object {
        var l = getLocal2d();
        if (l != null)
            return l;
        if (parent != null)
            return parent.getFirstLocal2d();
        return null;
    }

    public function getLocal3d() : h3d.scene.Object {
        return null;
    }

    // This should be only called in "OnMakeInstance" to get the relevant object on which you should attach
    final public function getNearestParentLocal3d() : h3d.scene.Object {
        var p = parent;
        while (p != null) {
            var l = p.getLocal3d();
            if (l != null)
                return l;
            p = p.parent;
        }
        return null;
    }

    public function getThisOrParentLocal3d() : h3d.scene.Object {
        var p = this;
        while (p != null) {
            var l = p.getLocal3d();
            if (l != null)
                return l;
            p = p.parent;
        }
        return null;
    }

    // Public API

    public function new(?parent:Prefab = null) {
        this.parent = parent;
        if (parent != null) {
            parent.children.push(this);
        }
    }

    /**Create a copy of this prefab and it's childrens, whitout initializing their fields**/
    private function copyDefault(?parent:Prefab = null) : Prefab {
        var thisClass = Type.getClass(this);
        var inst = Type.createInstance(thisClass, [parent]);
        for (child in children) {
            child.copyDefault(inst);
        }
        return inst;
    }

    public function getRoot() : Prefab {
        var root = this;

        // Note : because we always insert a "shadow parent" when we make
        // a prefab, the root is actually the prefab with a parent that has
        // no parent
        while (root.parent != null && root.parent.parent != null) {
            root = root.parent;
        }
        return root;
    }

    // Call the autogenerated make(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) function instead which is properly typed
    // for each prefab using macro
    @:noCompletion
    private final function _make_internal(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) : Prefab {
        var newInstance = copyDefault(root);
        newInstance.proto = this.proto;

        copy(this, newInstance, false, true);
        if (root == null)
            newInstance.setRoot(o2d, o3d);
        newInstance.instanciate();

        return newInstance;
    };

    public function setRoot(?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) {
        if (parent != null) {
            throw "prefab already has a parent, can't be root";
        }

        var root: Prefab = null;
        if (o2d != null) {
            var p2d = new Object2D();
            p2d.local2d = o2d;
            root = p2d;
        }
        else if (o3d != null) {
            var p3d = new Object3D();
            p3d.local3d = o3d;
            root = p3d;
        }

        if (root != null) {
            root.children.push(this);
            parent = root;
        }
    }

    // Like make but in-place
    public function instanciate() {
        onMake();

        refresh();

        function onPostMakeRecursive(p:Prefab) {
            boardcastPrefabPostMake(p);
            for (c in p.children) {
                onPostMakeRecursive(c);
            }
        }
        onPostMakeRecursive(this);
    }

    // Override this function if you want to controll how the childrens are
    // made
    private function onMake() : Void {
        onMakeInstance();
        for (c in children) {
            c.onMake();
        }
    }

    // Override this function to create runtime objects from this prefab
    private function onMakeInstance() : Void {

    }

    /**
		Allows to customize how an instance gets updated when a property name changes.
		You can also call updateInstance(ctx) in order to force whole instance synchronization against current prefab data.
	**/
    public function updateInstance(?propName : String ) {
	}

    /**
		Removes the created instance for this prefab only (not is children).
		If false is returned, the instance could not be removed and the whole context scene needs to be rebuilt
	**/
	public function removeInstance() : Bool {
		return false;
	}

    public static function copy(source:Prefab, dest:Prefab, useProperty:Bool, copyNull:Bool)
    {
        copyShallow(source, dest, useProperty, copyNull, source.getSerializableProps());
        for (idx in 0...source.children.length) {
            copy(source.children[idx], dest.children[idx], useProperty, copyNull);
        }
    }


    public final function destroy() {
        if (parent != null) {
            parent.children.remove(this);
        }
        onDestroy();
    }

    /**
		Returns the first parent in the tree matching the specified class or null if not found.
	**/
	public function getParent<T:Prefab>( c : Class<T> ) : Null<T> {
		var p = parent;
		while(p != null) {
			var inst = p.to(c);
			if(inst != null) return inst;
			p = p.parent;
		}
		return null;
	}

    // Private api to implement
    //


    #if editor
    private function onEditorInit() {

    }
    #end

    private function onDestroy() {

    }

    public final function change(propName:String) {
        onChange(propName);
    }

    /**If null, then consider that all properties have changed**/
    private function onChange(propName:String) {

    }

    // Only copy a prefab serializable properties without it's children
    private static function copyShallow(source:Dynamic, dest:Dynamic, useProperty:Bool, copyNull:Bool, props:Array<PrefabField>) {
        var set = useProperty ? Reflect.setProperty : Reflect.setField;

        for (prop in props) {
            var v : Dynamic = Reflect.getProperty(source, prop.name);
            if (v != null || copyNull) {
                switch (Type.typeof(v)) {
                    case TClass(c):
                        trace(Type.getClassName(c));
                        switch(c) {
                            case cast Array:
                                var v:Array<Dynamic> = v;
                                set(dest, prop.name, v.copy());
                            case cast String:
                                var v:String = v;
                                set(dest, prop.name, v);
                                trace("set string " +v + " (" + prop.name + ")");
                            default:
                                // TODO : oh no
                                set(dest, prop.name, haxe.Json.parse(haxe.Json.stringify(v)));
                        }
                    default:
                        set(dest, prop.name, v);
                }
            }
        }
    }

    // Call all the setters of this object and its children
    public function refresh() {
        for (field in getSerializableProps()) {
            if (field.hasSetter) {
                Reflect.setProperty(this, field.name, Reflect.getProperty(this, field.name));
            }
        }
        for (child in children) {
            child.refresh();
        }
    }

    public static function loadFromDynamic(data:Dynamic, parent:Prefab = null) : Prefab {
        var type : String = data.type;

        if (type == null) throw  "missing type in data";

        var classEntry = registry.get(type);
        if (classEntry == null) throw "unknown prefab type " + type;

        var prefabInstance = Type.createInstance(classEntry.prefabClass, [parent]);

        prefabInstance.load(data);

        var children = Std.downcast(Reflect.field(data, "children"), Array);
        if (children != null) {
            for (child in children) {
                loadFromDynamic(child, prefabInstance);
            }
        }

        return prefabInstance;
    }

    private function load(data : Dynamic) : Void {
        copyShallow(data, this, false, false, getSerializableProps());
    }

    final private function save(?to: Dynamic) : Dynamic {
        if (to == null)
            to = {};
        copyShallow(this, to, false, false, getSerializableProps());
        return to;
    }

    public static function loadFromPath(path: String, parent: Prefab = null) : Prefab {
        var pref : Prefab = cache[path];
        if (pref != null)
            return pref;
        var res = hxd.res.Loader.currentInstance.load(path);
        var data = haxe.Json.parse(res.toText());
        var pref = Prefab.loadFromDynamic(data, parent);
        pref.proto = new ProtoPrefab(pref, path);
        return pref;
    }

    static var cache : Map<String, Prefab> = new Map();

    public final function toString() : String{
        return haxe.Json.stringify(serializeToDynamic(), null, "\t");
    }

    // Replace this prefab by make()-ing on otherTemplate in it's place,
    // then detroys itself. Returns the newly created object
    public function replaceWith(otherTemplate:Prefab) : Prefab {
        var i = parent.children.indexOf(this);
        parent.children[i] = otherTemplate.make(parent);
        destroy();
        return parent.children[i];
    }

    // Recursively copy this prefab and it's children into a dynamic object, containing
    // all the serializable properties and the type of the object
    public function serializeToDynamic() : Dynamic {
        var thisClass = Type.getClass(this);
        var typeName = getClassTypeName(thisClass);
        var dyn : Dynamic = {
            type: typeName,
        };

        save(dyn);

        if (children.length > 0) {
            var serChildren = [];
            for (child in children) {
                serChildren.push(child.serializeToDynamic());
            }
            dyn.children = serChildren;
        }

        return dyn;
    }


    // Helpers function for meta
    public final function getSerializableProps() : Array<PrefabField> {
        return getSerializablePropsForClass(Type.getClass(this));
    }

    inline public static function getSerializablePropsForClass(cl : Class<Prefab>) {
        return (cl:Dynamic).getSerializablePropsStatic();
    }

    public static function getClassTypeName(cl : Class<Prefab>) : String {
        for (k => v in registry) {
            if (cl == v.prefabClass) {
                return k;
            }
        }
        return null;
    }

    public static function getPrefabInfoByName(name:String) : PrefabInfo {
        return registry[name];
    }

    private static var registry : Map<String, PrefabInfo> = new Map();

    public static function register(typeName : String, prefabClass: Class<hrt.prefab2.Prefab>) {
        var info : hide.prefab2.HideProps = cast Type.createEmptyInstance(prefabClass).getHideProps();

        registry.set(typeName, {prefabClass: prefabClass #if editor, inf : info #end});
        return true;
    }

    public static var _ = Prefab.register("prefab", Prefab);

	private static function boardcastPrefabPostMake(p:Prefab) {
		for (f in onPrefabPostMake)
			f(p);
	}

	public static var onPrefabPostMake: Array<(p:Prefab) -> Void> = [];



    // OLD API MIGRATION

    /**
		Returns all prefabs in the tree matching the specified class.
	**/
	public function flatten<T:Prefab>( ?cl : Class<T>, ?arr: Array<T> ) : Array<T> {
		if(arr == null)
			arr = [];
		if( cl == null )
			arr.push(cast this);
		else {
			var i = to(cl);
			if(i != null)
				arr.push(i);
		}
		for(c in children)
			c.flatten(cl, arr);
		return arr;
	}

    /**
        Returns all the prefab in the tree
    **/
    public function all(?arr: Array<Prefab>) : Array<Prefab> {
        return flatten(Prefab, []);
    }

    /**
		Converts the prefab to another prefab class.
		Returns null if not of this type.
	**/
	public function to<T:Prefab>( c : Class<T> ) : Null<T> {
		return Std.downcast(this, c);
	}

    /**
		Returns the absolute name path for this prefab
	**/
	public function getAbsPath(unique=false) {
		if(parent == null)
			return "";
		var path = name != null ? name : getDefaultName();
		if(unique) {
			var suffix = 0;
			for(i in 0...parent.children.length) {
				var c = parent.children[i];
				if(c == this)
					break;
				else {
					var cname = c.name != null ? c.name : c.getDefaultName();
					if(cname == path)
						++suffix;
				}
			}
			if(suffix > 0)
				path += "-" + suffix;
		}
		if(parent.parent != null)
			path = parent.getAbsPath(unique) + "." + path;
		return path;
	}

    /**
		Returns the default name for this prefab
	**/
	public function getDefaultName() : String {
		if(proto != null && proto.source != null) {
			var f = new haxe.io.Path(proto.source).file;
			f = f.split(" ")[0].split("-")[0];
			return f;
		}
		return type.split(".").pop();
	}

    public function locateObject( path : String ) {
		if( path == null )
			return null;
		var parts = path.split(".");
		var root = getRoot().getLocal3d();
		while( parts.length > 0 ) {
			var v = null;
			var pname = parts.shift();
			for( o in root )
				if( o.name == pname ) {
					v = o;
					break;
				}
			if( v == null ) {
				v = root.getObjectByName(pname);
				//if( v != null && v.parent != root ) v = null; ??
			}
			if( v == null ) {
				var parts2 = path.split(".");
				for( i in 0...parts.length ) parts2.pop();
				return null;
			}
			root = v;
		}
		return root;
	}

    /**
		Find several prefabs in the tree by calling `f` on each and returning all the not-null values returned.
	**/
	public function findAll<T>( f : Prefab -> Null<T>, ?followRefs : Bool, ?arr : Array<T> ) : Array<T> {
		if( arr == null ) arr = [];
		var v = f(this);
		if( v != null )
			arr.push(v);
        if (followRefs) {
            var ref = to(Reference);
            if (ref != null) {
                ref.pref.findAll(f, followRefs, arr);
            }
        }
		for( o in children )
			o.findAll(f,followRefs,arr);
		return arr;
	}

    // "override" this function in your child class
    public function getHideProps() : hide.prefab2.HideProps {
		return { icon : "question-circle", name : "Unknown" };
	}

    /**
	 	If the prefab `props` represent CDB data, returns the sheet name of it, or null.
	 **/
	public function getCdbType() : String {
		if( props == null )
			return null;
		return Reflect.field(props, "$cdbtype");
	}

    /**
		Iterate over children prefab
	**/
	public inline function iterator() : Iterator<Prefab> {
		return children.iterator();
	}

    	/**
		Simlar to get() but returns null if not found.
	**/
	public function getOpt<T:Prefab>( cl : Class<T>, ?name : String, ?followRefs : Bool ) : T {
		if( name == null || this.name == name ) {
			var cval = to(cl);
			if( cval != null ) return cval;
		}
		for( c in children ) {
			var p = c.getOpt(cl, name, followRefs);
			if( p != null )
				return p;
		}
		return null;
	}

	/**
		Search the prefab tree for the prefab matching the given prefab class (and name, if specified).
		Throw an exception if not found. Uses getOpt() to return null instead.
	**/
	public function get<T:Prefab>( cl : Class<T>, ?name : String ) : T {
		var v = getOpt(cl, name);
		if( v == null )
			throw "Missing prefab " + (name == null ? Type.getClassName(cl) : (cl == null ? name : name+"(" + Type.getClassName(cl) + ")"));
		return v;
	}

    /**
		Return all prefabs in the tree matching the given prefab class.
	**/
	public function getAll<T:Prefab>( cl : Class<T>, ?followRefs : Bool, ?arr: Array<T> ) : Array<T> {
		return findAll(function(p) return p.to(cl), followRefs, arr);
	}

    #if editor
	public function makeInteractive() : hxd.SceneEvents.Interactive {
		return null;
	}

	/**
		Allows to customize how the prefab instance changes when selected/unselected within Hide.
		Selection of descendants is skipped if false is returned.
	**/
	public function setSelected(b : Bool ) {
		return true;
	}

    /**
		Search the prefab tree for the prefab matching the given name, returns null if not found
	**/
	public function getPrefabByName( name : String ) {
		if( this.name == name )
			return this;
		for( c in children ) {
			var p = c.getPrefabByName(name);
			if( p != null )
				return p;
		}
		return null;
	}

    public function edit(editContext : hide.prefab2.EditContext) {

    }

    #end

}