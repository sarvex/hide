package hrt.prefab2;

using hrt.prefab2.Object3D;
using hrt.prefab2.Object2D;



typedef PrefabField = {
    var name : String;
    var hasSetter : Bool;
    var meta : PrefabMeta;
    var defaultValue : Dynamic;
}

typedef PrefabMeta = {
    var ?doc : String;
    var ?range_min : Float;
    var ?range_max : Float;
    var ?range_step : Float;
}

class InstanciateContext {
    public function new(local2d: h2d.Object, local3d: h3d.scene.Object) {
        this.local2d = local2d;
        this.local3d = local3d;
    }

    public var local2d : h2d.Object = null;
    public var local3d : h3d.scene.Object = null;
    public var forceInstanciate : Bool = false; /** Force the instanciation of the prefab even if it's a template **/
}

typedef PrefabInfo = {prefabClass : Class<Prefab> #if editor, inf : hide.prefab2.HideProps #end};

@:keepSub
@:autoBuild(hrt.prefab2.Macros.buildPrefab())
@:build(hrt.prefab2.Macros.buildPrefab())
class Prefab {

    /**
        The registered type name for this prefab, used to identify a prefab when serializing
    **/
    public var type(get, never) : String;

    /**
        The name of the prefab in the tree view
    **/
    @:s public var name : String = "";

    /**
        A storage for some extra properties
    **/
    @:s public var props : Any = null;

    /**
        Tells if the prefab will create an instance when calling make() or be ignored. Also apply to this prefab children.
    **/
    @:s public var enabled : Bool = true;

    /**
        Tells if the prefab will create an instance when used in an other prefab or in game. Also apply to this prefab children.
    **/
    @:s public var editorOnly : Bool = false;

    /**
        Tells if the prefab will create an instance when used in editor. Also apply to this prefab children.
    **/
    @:s public var inGameOnly : Bool = false;

    /**
        Prevent the prefab from being selected in Hide. Also apply to this prefab children.
    **/
    // TODO(ces) : Concept of editor only serializable flags ?
    // maybe store this like the visibility (in the user prefs instead of the prefab ???)
    // Also maybe store all the flags in a single variable ???
    @:s public var locked : Bool = false;

    /**
        The parent of the prefab in the tree view
    **/
    public var children : Array<Prefab> = [];

    /**
        The parent of the prefab in the tree view
    **/
    public var parent : Prefab = null;


    public function new(?parent:Prefab = null) {
        this.parent = parent;
        if (parent != null) {
            parent.children.push(this);
        }
    }


    function get_type() {
        var thisClass = Type.getClass(this);
        return getClassTypeName(thisClass);
    }



    /**The original prefab that this prefab is derived from.**/
    public var proto : ProtoPrefab = null;

    public function getSource() : String {
        return null;
    }

    public function findFirstLocal2d() : h2d.Object {
        return findUp(
            (p) -> p.getLocal2d()
        );
    }

    // Find the first local3d object, either in this object or it's parents
    public function findFirstLocal3d() : h3d.scene.Object {
        return findUp(
            (p) -> p.getLocal3d()
        );
    }


    /**Create a copy of this prefab and it's childrens, whitout initializing their fields**/
    function copyDefault(?parent:Prefab = null) : Prefab {
        var thisClass = Type.getClass(this);
        var inst = Type.createInstance(thisClass, [parent]);
        copyShallow(this, inst, false, true, true, getSerializableProps());
        for (child in children) {
            child.copyDefault(inst);
        }
        return inst;
    }

    public function getRoot() : Prefab {
        var root = this;

        while (root.parent != null) {
            root = root.parent;
        }
        return root;
    }

    // Call the autogenerated make(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) function instead which is properly typed
    // for each prefab using macro
    @:noCompletion
    final function makeInternal(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) : Prefab {
        var newInstance = copyDefault(root);
        newInstance.proto = this.proto;

        o2d = o2d != null ? o2d : (root != null ? root.findFirstLocal2d() : null);
        o3d = o3d != null ? o3d : (root != null ? root.findFirstLocal3d() : null);
        var params = new InstanciateContext(o2d, o3d);

        newInstance.instanciate(params);

        return newInstance;
    };

    // Like make but in-place
    public function instanciate(params: InstanciateContext) {
        var forceInstanciate = (params.forceInstanciate != null && params.forceInstanciate);
        if (!forceInstanciate && (proto.prefab == this))
            throw "Can't instanciate a template prefab unless params.forceInstanciate is true.";
        makeInstanceRec(params);

        refresh();

        function onPostMakeRecursive(p:Prefab) {
            boardcastPrefabPostMake(p);
            for (c in p.children) {
                onPostMakeRecursive(c);
            }
        }
        onPostMakeRecursive(this);
    }

    // Override this function to create runtime objects from this prefab
    function makeInstance(ctx: InstanciateContext) : Void {

    }

    // Override this function if you want to controll how the childrens are
    // made
    function makeInstanceRec(params: InstanciateContext) : Void {
        if (!enabled) return;
        makeInstance(params);
        var new2d = this.getLocal2d();
        if (new2d != null)
            params.local2d = new2d;
        var new3d = this.getLocal3d();
        if (new3d != null)
            params.local3d = new3d;
        for (c in children) {
            c.makeInstanceRec(params);
        }
    }

    /**
        Allows to customize how an instance gets updated when a property name changes.
        You can also call updateInstance(ctx) in order to force whole instance synchronization against current prefab data.
    **/
    public function updateInstance(?propName : String ) {
    }

    /**
        Removes the created instance for this prefab only (not is children).
        If false is returned, the instance could not be removed and the whole context scene needs to be rebuilt
    **/
    public function removeInstance() : Bool {
        return false;
    }


    // Copy all the fields from this prefab to the target prefab, recursively
    public static function copy(source:Prefab, dest:Prefab, useProperty:Bool, copyNull:Bool)
    {
        copyShallow(source, dest, useProperty, copyNull, false, source.getSerializableProps());
        for (idx in 0...source.children.length) {
            copy(source.children[idx], dest.children[idx], useProperty, copyNull);
        }
    }

    // KEEP ???
    public final function destroyPrefab() {
        if (parent != null) {
            parent.children.remove(this);
        }
        // Make recursive ???

        destroy();
    }

    /**
        Returns the first parent in the tree matching the specified class or null if not found.
    **/
    public function getParent<T:Prefab>( c : Class<T> ) : Null<T> {
        if (parent != null)
            return parent.findUp(p -> p.to(c));
        return null;
    }


    private function destroy() {

    }

    // Only copy a prefab serializable properties without it's children
    static function copyShallow(source:Dynamic, dest:Dynamic, useProperty:Bool, copyNull:Bool, copyDefault: Bool, props:Array<PrefabField>) {
        var set = useProperty ? Reflect.setProperty : Reflect.setField;

        for (prop in props) {
            var v : Dynamic = Reflect.getProperty(source, prop.name);
            var shouldCopy = true;
            shouldCopy = shouldCopy && (v != null || copyNull);
            shouldCopy = shouldCopy && (copyDefault || useProperty || v != prop.defaultValue);
            //shouldCopy &= (copyDefault || ) 
            if (shouldCopy) {
                switch (Type.typeof(v)) {
                    case TClass(c):
                        trace(Type.getClassName(c));
                        switch(c) {
                            case cast Array:
                                var v:Array<Dynamic> = v;
                                set(dest, prop.name, v.copy());
                            case cast String:
                                var v:String = v;
                                set(dest, prop.name, v);
                                trace("set string " +v + " (" + prop.name + ")");
                            default:
                                // TODO : oh no
                                set(dest, prop.name, haxe.Json.parse(haxe.Json.stringify(v)));
                        }
                    default:
                        set(dest, prop.name, v);
                }
            }
        }
    }

    // Call all the setters of this object and its children
    public function refresh() {
        for (field in getSerializableProps()) {
            if (field.hasSetter) {
                Reflect.setProperty(this, field.name, Reflect.getProperty(this, field.name));
            }
        }
        for (child in children) {
            child.refresh();
        }
    }

    public static function createFromDynamic(data:Dynamic, parent:Prefab = null) : Prefab {
        var type : String = data.type;

        if (type == null) throw  "missing type in data";

        var classEntry = registry.get(type);
        if (classEntry == null) throw "unknown prefab type " + type;

        // Converting (old) prefabs roots to Object3D automatically
        if (parent == null && classEntry.prefabClass == Prefab)
            classEntry = registry.get("object3D");

        var prefabInstance = Type.createInstance(classEntry.prefabClass, [parent]);

        prefabInstance.load(data);

        var children = Std.downcast(Reflect.field(data, "children"), Array);
        if (children != null) {
            for (child in children) {
                createFromDynamic(child, prefabInstance);
            }
        }

        return prefabInstance;
    }

    public static function createFromPath(path: String, parent: Prefab = null) : Prefab {
        return hxd.res.Loader.currentInstance.load(path).to(hrt.prefab2.Resource).load();
        //return null;
    }

    /** Copy all the properties in data to this prefab object. This is not recursive**/
    function load(data : Dynamic) : Void {
        copyShallow(data, this, false, false, false, getSerializableProps());
    }

    /** Save all the properties to the given dynamic object. This is not recursive. Returns the updated dynamic object.
        If to is null, a new dynamic object is created automatically and returned by the
    **/
    final function save(?to: Dynamic) : Dynamic {
        if (to == null)
            to = {};
        copyShallow(this, to, false, false, false, getSerializableProps());
        return to;
    }

    static var cache : Map<String, Prefab> = new Map();

    public final function toString() : String{
        return haxe.Json.stringify(serializeToDynamic(), null, "\t");
    }

    // Recursively copy this prefab and it's children into a dynamic object, containing
    // all the serializable properties and the type of the object
    public function serializeToDynamic() : Dynamic {
        var thisClass = Type.getClass(this);
        var typeName = getClassTypeName(thisClass);
        var dyn : Dynamic = {
            type: typeName,
        };

        save(dyn);

        if (children.length > 0) {
            var serChildren = [];
            for (child in children) {
                serChildren.push(child.serializeToDynamic());
            }
            dyn.children = serChildren;
        }

        return dyn;
    }


    // Helpers function for meta
    public final function getSerializableProps() : Array<PrefabField> {
        return getSerializablePropsForClass(Type.getClass(this));
    }

    inline public static function getSerializablePropsForClass(cl : Class<Prefab>) {
        return (cl:Dynamic).getSerializablePropsStatic();
    }

    public static function getClassTypeName(cl : Class<Prefab>) : String {
        for (k => v in registry) {
            if (cl == v.prefabClass) {
                return k;
            }
        }
        return null;
    }

    public static function getPrefabInfoByName(name:String) : PrefabInfo {
        return registry[name];
    }

    static var registry : Map<String, PrefabInfo> = new Map();

    public static function register(typeName : String, prefabClass: Class<hrt.prefab2.Prefab>) {
        var info : hide.prefab2.HideProps = cast Type.createEmptyInstance(prefabClass).getHideProps();

        registry.set(typeName, {prefabClass: prefabClass #if editor, inf : info #end});
        return true;
    }

    public static var _ = Prefab.register("prefab", Prefab);

    static function boardcastPrefabPostMake(p:Prefab) {
        for (f in onPrefabPostMake)
            f(p);
    }

    public static var onPrefabPostMake: Array<(p:Prefab) -> Void> = [];



    // OLD API MIGRATION

    /**
        Returns all prefabs in the tree matching the specified class.
    **/
    public function flatten<T:Prefab>( ?cl : Class<T>, ?arr: Array<T> ) : Array<T> {
        if(arr == null)
            arr = [];
        if( cl == null )
            arr.push(cast this);
        else {
            var i = to(cl);
            if(i != null)
                arr.push(i);
        }
        for(c in children)
            c.flatten(cl, arr);
        return arr;
    }

    /**
        Returns all the prefab in the tree
    **/
    public function all(?arr: Array<Prefab>) : Array<Prefab> {
        return flatten(Prefab, []);
    }

    /**
        Converts the prefab to another prefab class.
        Returns null if not of this type.
    **/
    public function to<T:Prefab>( c : Class<T> ) : Null<T> {
        return Std.downcast(this, c);
    }

    /**
        Returns the absolute name path for this prefab
    **/
    public function getAbsPath(unique=false) {
        if(parent == null)
            return "";
        var path = name != null ? name : getDefaultName();
        if(unique) {
            var suffix = 0;
            for(i in 0...parent.children.length) {
                var c = parent.children[i];
                if(c == this)
                    break;
                else {
                    var cname = c.name != null ? c.name : c.getDefaultName();
                    if(cname == path)
                        ++suffix;
                }
            }
            if(suffix > 0)
                path += "-" + suffix;
        }
        if(parent.parent != null)
            path = parent.getAbsPath(unique) + "." + path;
        return path;
    }

    /**
        Returns the default name for this prefab
    **/
    public function getDefaultName() : String {
        if(proto != null && proto.source != null) {
            var f = new haxe.io.Path(proto.source).file;
            f = f.split(" ")[0].split("-")[0];
            return f;
        }
        return type.split(".").pop();
    }

    public function locateObject( path : String ) {
        if( path == null )
            return null;
        var parts = path.split(".");
        var root = getRoot().getLocal3d();
        while( parts.length > 0 ) {
            var v = null;
            var pname = parts.shift();
            for( o in root )
                if( o.name == pname ) {
                    v = o;
                    break;
                }
            if( v == null ) {
                v = root.getObjectByName(pname);
                //if( v != null && v.parent != root ) v = null; ??
            }
            if( v == null ) {
                var parts2 = path.split(".");
                for( i in 0...parts.length ) parts2.pop();
                return null;
            }
            root = v;
        }
        return root;
    }

    /**
        Find several prefabs in the tree by calling `f` on each and returning all the non-null values returned.
    **/
    public function findAll<T>( f : Prefab -> Null<T>, ?followRefs : Bool, ?arr : Array<T> ) : Array<T> {
        if( arr == null ) arr = [];
        var v = f(this);
        if( v != null )
            arr.push(v);
        if (followRefs) {
            var ref = to(Reference);
            if (ref != null && ref.refInstance != null) {
                ref.refInstance.findAll(f, followRefs, arr);
            }
        }
        for( o in children )
            o.findAll(f,followRefs,arr);
        return arr;
    }

    /**
        Allows to customize how the prefab object is displayed / handled within Hide
    **/
    public function getHideProps() : hide.prefab2.HideProps {
        return { icon : "question-circle", name : "Unknown" };
    }

    /**
         If the prefab `props` represent CDB data, returns the sheet name of it, or null.
     **/
    public function getCdbType() : String {
        if( props == null )
            return null;
        return Reflect.field(props, "$cdbtype");
    }

    /**
        Iterate over children prefab
    **/
    public inline function iterator() : Iterator<Prefab> {
        return children.iterator();
    }

    /**
        Simlar to get() but returns null if not found.
    **/
    public function getOpt<T:Prefab>( cl : Class<T>, ?name : String, ?followRefs : Bool ) : Null<T> {
        if( name == null || this.name == name ) {
            var cval = to(cl);
            if( cval != null ) return cval;
        }
        for( c in children ) {
            var p = c.getOpt(cl, name, followRefs);
            if( p != null )
                return p;
        }
        return null;
    }

    /**
        Search the prefab tree for the prefab matching the given prefab class (and name, if specified).
        Throw an exception if not found. Uses getOpt() to return null instead.
    **/
    public function get<T:Prefab>( cl : Class<T>, ?name : String ) : T {
        var v = getOpt(cl, name);
        if( v == null )
            throw "Missing prefab " + (name == null ? Type.getClassName(cl) : (cl == null ? name : name+"(" + Type.getClassName(cl) + ")"));
        return v;
    }

    /**
        Return all prefabs in the tree matching the given prefab class.
    **/
    public function getAll<T:Prefab>( cl : Class<T>, ?followRefs : Bool, ?arr: Array<T> ) : Array<T> {
        return findAll(function(p) return p.to(cl), followRefs, arr);
    }

    public static function isOfType( original : Class<Prefab>, parent : Class<Prefab> ) {
        var c : Class<Dynamic> = original;
        while( c != null ) {
            if( c == parent ) return true;
            c = Type.getSuperClass(c);
        }
        return false;
    }

    /**
        Apply the filter function to this object, returning the result of filter if it's not null.
        If the filters returns null, it's then applied to the parent of this prefab, and this recursively.
    **/
    inline public function findUp<T>(filter : (p:Prefab) -> Null<T>) : Null<T> {
        var current = this;
        var val = null;
        while(current != null && val == null) {
            val = filter(current);
            current = current.parent;
        }
        return val;
    }

    #if editor
    public function makeInteractive() : hxd.SceneEvents.Interactive {
        return null;
    }

    /**
        Allows to customize how the prefab instance changes when selected/unselected within Hide.
        Selection of descendants is skipped if false is returned.
    **/
    public function setSelected(b : Bool ) {
        return true;
    }

    /**
        Search the prefab tree for the prefab matching the given name, returns null if not found
    **/
    public function getPrefabByName( name : String ) {
        if( this.name == name )
            return this;
        for( c in children ) {
            var p = c.getPrefabByName(name);
            if( p != null )
                return p;
        }
        return null;
    }

    public function edit(editContext : hide.prefab2.EditContext) {

    }

    #end

}