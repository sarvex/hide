package hrt.prefab2;

typedef PrefabField = {
    var name : String;
    var hasSetter : Bool;
    var meta : PrefabMeta;
}

typedef PrefabMeta = {
    var ?doc : String;
    var ?range_min : Float;
    var ?range_max : Float;
    var ?range_step : Float;
}

@:keepSub
@:autoBuild(hrt.prefab2.Macros.buildPrefab())
@:build(hrt.prefab2.Macros.buildPrefab())
class Prefab {
    @:s public var name : String = "";

    public var children : Array<Prefab> = [];

    public var parent : Prefab = null;

    /**The original prefab that this prefab is derived from.**/
    public var prototype : Prefab = null;

    public function getLocal2d() : h2d.Object {
        return null;
    }

    public function getFirstLocal2d() : h2d.Object {
        var l = getLocal2d();
        if (l != null)
            return l;
        if (parent != null)
            return parent.getFirstLocal2d();
        return null;
    }

    public function getLocal3d() : h3d.scene.Object {
        return null;
    }

    public function getFirstLocal3d() : h3d.scene.Object {
        var l = getLocal3d();
        if (l != null)
            return l;
        if (parent != null)
            return parent.getFirstLocal3d();
        return null;
    }

    // Public API

    public function new(?parent:Prefab = null) {
        this.parent = parent;
    }

    /**Create a copy of this prefab and it's childrens, whitout initializing their fields**/
    private function copyDefault(?parent:Prefab = null) : Prefab {
        var thisClass = Type.getClass(this);
        var inst = Type.createInstance(thisClass, [parent]);
        for (child in children) {
            inst.children.push(child.copyDefault(inst));
        }
        return inst;
    }

    public function getRoot() : Prefab {
        var root = this;

        // Note : because we always insert a "shadow parent" when we make
        // a prefab, the root is actually the prefab with a parent that has
        // no parent
        while (root.parent != null && root.parent.parent != null) {
            root = root.parent;
        }
        return root;
    }

    // Call the autogenerated make(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) function instead which is properly typed
    // for each prefab using macro
    @:noCompletion
    private final function _make_internal(?root: Prefab = null, ?o2d: h2d.Object = null, ?o3d: h3d.scene.Object = null) : Prefab {
        var newInstance = copyDefault(null);
        newInstance.prototype = this.prototype != null ? this.prototype : this;

        copy(this, newInstance, false, true);

        var transientParent = false;
        if (root == null) {
            if (o2d != null) {
                var p2d = new Object2D();
                p2d.local2d = o2d;
                root = p2d;
            }
            else if (o3d != null) {
                var p3d = new Object3D();
                p3d.local3d = o3d;
                root = p3d;
            }
            else {
                root = new Prefab(null);
            }
            root.children.push(newInstance);
        }

        newInstance.parent = root;

        function onMakeRecursive(p:Prefab) {
            p.onMake();
            for (c in p.children) {
                onMakeRecursive(c);
            }
        }

        onMakeRecursive(newInstance);

        /*if (transientParent) {
            newInstance.parent = null;
        }*/

        newInstance.refresh();

        boardcastPrefabPostMake(newInstance);

        return newInstance;
    };

    public static function copy(source:Prefab, dest:Prefab, useProperty:Bool, copyNull:Bool)
    {
        copyShallow(source, dest, useProperty, copyNull, source.getSerializableProps());
        for (idx in 0...source.children.length) {
            copy(source.children[idx], dest.children[idx], useProperty, copyNull);
        }
    }

    public final function destroy() {
        onDestroy();
    }

    // Private api to implement
    //

    private function onMake() {

    }


    private function onDestroy() {

    }

    public final function change(propName:String) {
        onChange(propName);
    }

    /**If null, then consider that all properties have changed**/
    private function onChange(propName:String) {

    }

    // Only copy a prefab serializable properties without it's children
    private static function copyShallow(source:Dynamic, dest:Dynamic, useProperty:Bool, copyNull:Bool, props:Array<PrefabField>) {
        var set = useProperty ? Reflect.setProperty : Reflect.setField;

        for (prop in props) {
            var v : Dynamic = Reflect.getProperty(source, prop.name);
            if (v != null || copyNull) {
                switch (Type.typeof(v)) {
                    case TClass(c):
                        trace(Type.getClassName(c));
                        switch(c) {
                            case cast Array:
                                var v:Array<Dynamic> = v;
                                set(dest, prop.name, v.copy());
                            case cast String:
                                var v:String = v;
                                set(dest, prop.name, v);
                                trace("set string " +v + " (" + prop.name + ")");
                            default:
                                throw "Can't serialize this class";
                        }
                    default:
                        set(dest, prop.name, v);
                }
            }
        }
    }

    // Call all the setters of this object and its children
    private function refresh() {
        for (field in getSerializableProps()) {
            if (field.hasSetter) {
                Reflect.setProperty(this, field.name, Reflect.getProperty(this, field.name));
            }
        }
        for (child in children) {
            child.refresh();
        }
    }

    public static function loadFromDynamic(data:Dynamic, parent:Prefab = null) : Prefab {
        var type : String = data.type;

        if (type == null) throw  "missing type in data";

        var classEntry = registry.get(type);
        if (classEntry == null) throw "unknown prefab type " + type;

        var prefabInstance = Type.createInstance(classEntry.prefabClass, [parent]);

        copyShallow(data, prefabInstance, false, false, prefabInstance.getSerializableProps());

        var children = Std.downcast(Reflect.field(data, "children"), Array);
        if (children != null) {
            for (child in children) {
                prefabInstance.children.push(loadFromDynamic(child, prefabInstance));
            }
        }

        return prefabInstance;
    }

    public static function loadFromPath(path: String, parent: Prefab = null) : Prefab {
        /*var pref : Prefab = cache[path];
        if (pref != null)
            return pref;
        */
        var res = hxd.Res.load(path);
        var data = haxe.Json.parse(res.toText());
        var pref = Prefab.loadFromDynamic(data, parent);
        return pref;
    }

    static var cache : Map<String, Prefab> = new Map();

    public final function toString() : String{
        return haxe.Json.stringify(serializeToDynamic(), null, "\t");
    }

    // Replace this prefab by make()-ing on otherTemplate in it's place,
    // then detroys itself. Returns the newly created object
    public function replaceWith(otherTemplate:Prefab) : Prefab {
        var i = parent.children.indexOf(this);
        parent.children[i] = otherTemplate.make(parent);
        destroy();
        return parent.children[i];
    }

    // Recursively copy this prefab and it's children into a dynamic object, containing
    // all the serializable properties and the type of the object
    public function serializeToDynamic() : Dynamic {
        var thisClass = Type.getClass(this);
        var typeName = getClassTypeName(thisClass);
        var dyn : Dynamic = {
            type: typeName,
        };

        copyShallow(this, dyn, false, false, getSerializableProps());

        if (children.length > 0) {
            var serChildren = [];
            for (child in children) {
                serChildren.push(child.serializeToDynamic());
            }
            dyn.children = serChildren;
        }

        return dyn;
    }


    // Helpers function for meta
    public final function getSerializableProps() : Array<PrefabField> {
        return getSerializablePropsForClass(Type.getClass(this));
    }

    inline public static function getSerializablePropsForClass(cl : Class<Prefab>) {
        return (cl:Dynamic).getSerializablePropsStatic();
    }

    public static function getClassTypeName(cl : Class<Prefab>) : String {
        for (k => v in registry) {
            if (cl == v.prefabClass) {
                return k;
            }
        }
        return null;
    }

    private static var registry : Map<String, {prefabClass : Class<Prefab>}> = new Map();

    public static function register(typeName : String, prefabClass: Class<Prefab>) {
        registry.set(typeName, {prefabClass: prefabClass});
        return true;
    }

    public static var _ = Prefab.register("Prefab", Prefab);

	private static function boardcastPrefabPostMake(p:Prefab) {
		for (f in onPrefabPostMake)
			f(p);
	}

	public static var onPrefabPostMake: Array<(p:Prefab) -> Void> = [];
}